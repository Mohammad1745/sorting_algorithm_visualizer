# Pathfinding Algorithm Visualizer

Welcome to Pathfinding Algorithm Visualizer! I am always fascinated by pathfinding algorithms, how they work and I wanted to visualize them in action. Hope that you shall enjoy playing around with this visualization tool just as much as I enjoyed building it.

The app is here: <a target="_blandk"> https://mohammad1745.github.io/pathfinder_algorithm_visualizer </a>(Chrome Recommended)

## Algorithms

This application supports the following algorithms:

**Dijkstra's Algorithm** : The father of pathfinding algorithms. It guarantees the shortest path. The algorithm doesn't have any idea about the location of end point. So, it searches every direction equally. That's why, it's the slowest of all. <a href="https://youtu.be/GazC3A4OQTE" target="_blank">Learn more...</a>

**A*** **Search** : Arguably the best pathfinding algorithm. It uses heuristics to guarantee the shortest path much faster than Dijkstra's Algorithm. The algorithm takes into account of the distance from end node . So, it searches the direction of the end node more than that of others. <a href="https://youtu.be/ySN5Wnu88nE" target="_blank">Learn more...</a>

**Greedy Best-first Search** : A faster, more heuristic-heavy version of A*. It does not guarantee the shortest path. The algorithm takes into account of the distance from end node and searches the direction of the end node first then the other directions.

**Swarm Algorithm** : A mixture of Dijkstra's Algorithm and A*. It does not guarantee the shortest path. The algorithm takes into account of the distance from end node and searches the direction of the end node more than that of others.

**Convergent Swarm Algorithm** : The faster, more heuristic-heavy version of Swarm. It does not guarantee the shortest path. The algorithm searches the direction of the end node heavily than that of others.

**Bidirectional Swarm Algorithm** : Swarm from both sides. It does not guarantee the shortest path


With these **Algorithms**, I added some patterns and maze to solve.
